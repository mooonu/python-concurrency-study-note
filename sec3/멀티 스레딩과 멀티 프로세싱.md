## 멀티 스레드
### Code
```python
import requests
import time
import os
import threading
from concurrent.futures import ThreadPoolExecutor


def fetcher(params):
    session = params[0]
    url = params[1]
    print(f"{os.getpid()} process | {threading.get_ident()} url : {url}")
    with session.get(url) as response:
        return response.text


def main():
    urls = ["https://google.com", "https://apple.com"] * 50

    executor = ThreadPoolExecutor(max_workers=10)

    with requests.Session() as session:
        # result = [fetcher(session, url) for url in urls]
        # print(result)
        params = [(session, url) for url in urls]
        results = list(executor.map(fetcher, params))
        print(results)


if __name__ == "__main__":
    start = time.time()
    main()
    end = time.time()
    print(end - start)  # 6.8
```

### Result
```
8668 process | 6231404544 url : https://google.com
8668 process | 6248230912 url : https://apple.com
8668 process | 6197751808 url : https://google.com
8668 process | 6180925440 url : https://apple.com
```

### Lesson
- 하나의 프로세스 안에서 여러 스레드가 동시에 작업을 처리
	- 위 코드에서는 최대 10개의 스레드를 가진다
- **하지만 python은 한 번에 하나의 스레드만 코드를 실행할 수 있다**
	- **스레드가 번갈아가며 실행될 뿐이라 병렬성이 불가능**하다.
	- GIL - 한 번에 1개의 스레드만 유지하는 락
- 입출력 작업에는 유용하지만, CPU 계산에는 멀티 프로세싱을 사용해야 한다.
- 다른 언어에서는 여러 스레드를 CPU 코어에 할당하여 실행 가능

---

## python CPU 계산에 멀티 스레딩이 필요없는 이유
### 일반적인 연산 코드
**Code**
```python
import time  
import os  
import threading  
  
nums = [50, 63, 32]  
  
  
def cpu_bound_func(num):  
    print(f"{os.getpid()} process | {threading.get_ident()} thread")  
    numbers = range(1, num)  
    total = 1  
    for i in numbers:  
        for j in numbers:  
            for k in numbers:  
                total *= i * j * k  
    return total  
  
  
def main():  
    results = [cpu_bound_func(num) for num in nums]  
    #print(results)  
  
  
if __name__ == "__main__":  
    start = time.time()  
    main()  
    end = time.time()  
    print(end - start)
```

**Result**
```bash
10560 process | 8781744128 thread #1 연산 종료
10560 process | 8781744128 thread #2 연산 종료
10560 process | 8781744128 thread #3 연산 종료
43.18548893928528 # 모든 연산이 끝난 뒤 걸린 시간
```

### 멀티 스레딩 코드
**Code**
```python
import time  
import os  
import threading  
from concurrent.futures import ThreadPoolExecutor  
  
nums = [50, 63, 32]  
  
  
def cpu_bound_func(num):  
    print(f"{os.getpid()} process | {threading.get_ident()} thread, {num}")  
    numbers = range(1, num)  
    total = 1  
    for i in numbers:  
        for j in numbers:  
            for k in numbers:  
                total *= i * j * k  
    return total  
  
  
def main():  
    executor = ThreadPoolExecutor(max_workers=10)  
    results = list(executor.map(cpu_bound_func, nums))  
    #print(results)  
  
  
if __name__ == "__main__":  
    start = time.time()  
    main()  
    end = time.time()  
    print(end - start)
```

**Result**
```bash
10815 process | 6138523648 thread, 50
10815 process | 6155350016 thread, 63
10815 process | 6172176384 thread, 32
47.08505702018738 # 모든 연산이 끝난 뒤 걸린 시간
```

**Lesson**
- GIL 때문에 단일 프로세스 내의 여러 스레드가 동시에 코드를 실행하지 못하므로 걸린 시간에 차이가 없다. (병렬성 x)

---

## 멀티 프로세싱
### Code
```python
import time  
import os  
import threading  
from concurrent.futures import ProcessPoolExecutor  
  
nums = [50, 63, 32]  
  
  
def cpu_bound_func(num):  
    print(f"{os.getpid()} process | {threading.get_ident()} thread, {num}")  
    numbers = range(1, num)  
    total = 1  
    for i in numbers:  
        for j in numbers:  
            for k in numbers:  
                total *= i * j * k  
    return total  
  
  
def main():  
    executor = ProcessPoolExecutor(max_workers=10)  
    results = list(executor.map(cpu_bound_func, nums))  
    #print(results)  
  
  
if __name__ == "__main__":  
    start = time.time()  
    main()  
    end = time.time()  
    print(end - start)
```

### Result
```bash
11151 process | 8781744128 thread, 50 #1 프로세스
11149 process | 8781744128 thread, 63 #2 프로세스
11150 process | 8781744128 thread, 32 #3 프로세스
39.27417302131653 
```
확실히 더 빠름

### Lesson
- 여러 개의 독립적인 프로세스를 생성하고, 각 CPU 코어에서 연산

---

## 참고
https://dongwooblog.tistory.com/175
